## 자료구조 정리

### Stack
1. LIFO(Last In, First Out)의 형태를 띠는 자료구조이며, 나중에 들어간 자료가 먼저 나오는 특성이 있다.
2. #include <stack>을 통해 사용할 수 있다.
3. 선언 : stack <자료형> s; 
4. 관련 함수들
 > - s.size() : s의 사이즈(물리적인 저장 용량이 아닌 원소적 개수)를 리턴
 > - s.empty() : s의 사이즈가 0인지 아닌지를 확인
 > - s.top() : s에 가장 나중에 들어간 원소를 리턴
 > - s.push(val) : s의 뒤에 val 추가
 > - s.pop() : s에 가장 나중에 들어간 원소를 삭제

### Queue
1. FIFO(First IN, First Out)의 형태를 띠는 자료구조이며, 먼저 들어온 자료가 먼저 나가는 특성이 있다.
2. #include <queue>를 통해 사용할 수 있다.
3. 선언 : queue <자료형> q;
4. 관련 함수들
 > - q.size() : q의 사이즈(물리적인 저장 용량이 아닌 원소의 개수)를 리턴
 > - q.empty() : q의 사이즈가 0인지 아닌지를 확인
 > - q.front() : q에 가장 먼저 들어간 원소를 리턴
 > - q.back() : q에 가장 나중에 들어간 원소를 리턴
 > - q.push(val) : q의 위(뒤)에 val 추가
 > - q.pop() : q에 가장 먼저 들어간 원소를 삭제
  
### Vector
1. 동적 배열로, 초기에 일정 크기의 메모리를 할당한 뒤 그것이 다 차게 되면 새로운 영역에 메모리를 더 큰 크기로 재할당한 뒤 원래 있던 값을 복사하는 방식을 이용한다.
2. #include <vector>를 통해 사용할 수 있다.
3. 선언 : vector <자료형> v;
4. 장점 : 배열 크기가 유동적이며, 데이터의 위치를 안다면 배열처럼 쉽게 접근이 가능하다.
5. 단점 : 중간 값 삭제가 쉽지 않다. (shift되므로 무겁다.) 또한 데이터가 순차적으로 저장되므로 검색 속도가 빠르지 않다.
6. 관련 함수들
 > - v.size() : v의 사이즈(물리적인 저장 용량이 아닌 원소적 개수)를 리턴
 > - v.empty() : v의 사이즈가 0인지 아닌지를 확인
 > - v.top() : v에 가장 나중에 들어간 원소를 리턴
 > - v.push_back(val) : v의 뒤에 val 추가
 > - v.pop_back() : v의 마지막 원소 제거
 > - v.clear() : v의 모든 원소 제거 (메모리는 남아있음)
 > - v.push_back(val) : v의 뒤에 val 추가
 > - v.pop_back() : v의 마지막 원소 제거
 > - v.begin() : 첫번째 원소의 주소 반환
 > - v.end() : 마지막 요소의 다음 주소 반환
